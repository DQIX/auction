<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>DQVCアイテムリスト生成</title>
  <style>
    :root {
      --bg:#0f172a; /* slate-900 */
      --panel:#111827; /* gray-900 */
      --muted:#94a3b8; /* slate-400 */
      --fg:#e5e7eb; /* gray-200 */
      --pri:#60a5fa; /* blue-400 */
      --accent:#22c55e; /* green-500 */
      --warn:#f59e0b; /* amber-500 */
      --err:#ef4444; /* red-500 */
      --card:#0b1220;
      --border:#1f2937; /* gray-800 */
    }
    :root[data-theme="light"]{
      --bg:#f3f4f6; /* gray-100 */
      --panel:#ffffff; /* white */
      --muted:#6b7280; /* gray-500 */
      --fg:#111827; /* gray-900 */
      --pri:#3b82f6; /* blue-500 */
      --accent:#16a34a; /* green-600 */
      --warn:#d97706; /* amber-600 */
      --err:#dc2626; /* red-600 */
      --card:#f9fafb; /* gray-50 */
      --border:#e5e7eb; /* gray-200 */
    }
    :root[data-theme="blue"]{
      --bg:#0a1930; /* deep blue */
      --panel:#0d223f;
      --muted:#93c5fd; /* blue-300 */
      --fg:#e0f2fe; /* sky-100 */
      --pri:#60a5fa; /* blue-400 */
      --accent:#38bdf8; /* sky-400 */
      --warn:#f59e0b;
      --err:#ef4444;
      --card:#0b1f3a;
      --border:#1e3a8a; /* indigo-800 */
    }
    :root[data-theme="gold"]{
      --bg:#15100a; /* dark brown */
      --panel:#1c150b;
      --muted:#f5d38c; /* soft gold */
      --fg:#fff7e6; /* warm light */
      --pri:#f59e0b; /* amber-500 */
      --accent:#fbbf24; /* amber-400 */
      --warn:#d97706;
      --err:#ef4444;
      --card:#1a1309;
      --border:#3f2d0f; /* brown-800 */
    }
    :root[data-theme="pink"]{
      --bg:#170f1c; /* deep plum */
      --panel:#1f1326;
      --muted:#f9a8d4; /* pink-300 */
      --fg:#fde7f3; /* pink-50ish */
      --pri:#ec4899; /* pink-500 */
      --accent:#f472b6; /* pink-400 */
      --warn:#f59e0b;
      --err:#ef4444;
      --card:#1b1122;
      --border:#4c1d95; /* violet-900 */
    }
    html, body { min-height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    header {
      position: sticky; top: 0; z-index: 5;
      background: linear-gradient(180deg, rgba(17,24,39,0.96), rgba(17,24,39,0.88));
      backdrop-filter: saturate(140%) blur(4px);
      border-bottom: 1px solid var(--border);
    }
    .wrap { max-width: 2000px; margin: 0 auto; padding: 12px 16px; }
    .header-row { display: flex; align-items: center; gap: 8px; }
    h1 { font-size: 18px; margin: 0; font-weight: 700; letter-spacing: .02em; }
    .grow { flex: 1; }
    .btn { appearance: none; border: 1px solid var(--border); background: var(--card); color: var(--fg); padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:hover { border-color: #2a384d; }
    .btn.primary { background: linear-gradient(180deg, #2563eb, #1d4ed8); border-color: #1e3a8a; color: white; }
    .btn.primary:disabled { opacity: .5; cursor: not-allowed; }
    .icon { width: 20px; height: 20px; vertical-align: -4px; }
    .toolbar { display: flex; gap: 8px; align-items: center; }
    .search { display: flex; align-items: center; gap: 8px; background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 8px 12px; }
    .search input { flex: 1; background: transparent; color: var(--fg); border: 0; outline: none; min-width: 140px; }
    .select { background: var(--card); color: var(--fg); border: 1px solid var(--border); border-radius: 10px; padding: 8px 10px; }

    main { max-width: 2000px; margin: 0 auto; padding: 12px 16px 40px; display: grid; grid-template-columns: 1fr; grid-template-areas: "selected" "items"; gap: 16px; }
    #itemsPanel { grid-area: items; }
    #selectedPanel { grid-area: selected; }
    @media (min-width: 1900px) {
      main { grid-template-columns: 1fr minmax(380px, 600px); grid-template-areas: "items selected"; align-items: start; }
    }

    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 14px; overflow: clip; }
    .panel h2 { margin: 0; font-size: 14px; font-weight: 700; padding: 10px 12px; border-bottom: 1px solid var(--border); background: var(--panel); }
    .panel .body { padding: 10px; }

    .type { margin-bottom: 8px; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: var(--card); }
    .type summary { list-style: none; cursor: pointer; padding: 8px 10px; background: var(--panel); font-weight: 700; color: var(--muted); }
    .type summary::-webkit-details-marker { display: none; }
    .type-items { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; padding: 10px; }
    @media (min-width: 1000px) { .type-items { grid-template-columns: repeat(3, minmax(0,1fr)); } }

    .item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border: 1px solid var(--border); border-radius: 10px; background: var(--card); }
    .item:hover { border-color: #2a384d; }
    .check { appearance: none; width: 18px; height: 18px; border: 2px solid #334155; border-radius: 6px; display: grid; place-items: center; background: var(--card); cursor: pointer; }
    .check:checked { background: var(--accent); border-color: var(--accent); }
    .check:checked::after { content: ""; width: 10px; height: 10px; background: white; border-radius: 2px; }

    .icon-sprite { width: 24px; height: 24px; display: inline-block; vertical-align: top; background-image: url('itemIcons.png'); background-repeat: no-repeat; image-rendering: pixelated; border-radius: 4px; box-shadow: inset 0 0 0 1px #0009; }
    .name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    body {
      min-width: 700px;
    }

    .selected-grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
    @media (min-width: 520px) { .selected-grid { grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media (min-width: 1700px) { .selected-grid { grid-template-columns: repeat(2, minmax(0,1fr)); } }
    .sel { align-items: center; gap: 8px; padding: 6px 8px; border: 1px solid var(--border); border-radius: 10px; background: var(--card); }
    .sel .remove { margin-left: auto; color: #fca5a5; cursor: pointer; }

    .dropzone { position: fixed; inset: 0; display: none; place-items: center; background: rgba(30,41,59,0.75); z-index: 50; }
    .dropzone.visible { display: grid; }
    .dropzone .inner { border: 2px dashed #60a5fa; padding: 24px; border-radius: 16px; background: var(--card); }

    .muted { color: var(--muted); }
    .error { color: #fecaca; background: #7f1d1d; border: 1px solid #b91c1c; padding: 8px 10px; border-radius: 10px; }
    .fields { display:flex; align-items:center; gap:6px; margin-left:auto; flex-wrap: wrap; }
    .num { width:72px; background: var(--card); color: var(--fg); border:1px solid var(--border); border-radius:8px; padding:4px 6px; }
    .suffix { color: var(--muted); font-size:12px; margin-left:-4px; margin-right:8px; }

    .bulk { margin-top: 8px; border: 1px solid var(--border); border-radius: 10px; background: var(--card); padding: 8px; }
    .bulk .title { font-weight:700; font-size:13px; color: var(--muted); margin-bottom:6px; }
    .bulk .fields { margin-left: 0; }

    /* >=1000px: show 4 columns for items grid */
    @media (min-width: 1400px) { .type-items { grid-template-columns: repeat(4, minmax(0,1fr)); } }

    /* Light theme header should be gray, not black */
    :root[data-theme="light"] header {
      background: linear-gradient(180deg, rgba(243,244,246,0.96), rgba(243,244,246,0.88));
    }
    /* Gold & Pink themes: match header to theme panel (was stuck dark) */
    :root[data-theme="gold"] header {
      background: linear-gradient(180deg, rgba(28,21,11,0.96), rgba(28,21,11,0.88));
    }
    :root[data-theme="pink"] header {
      background: linear-gradient(180deg, rgba(31,19,38,0.96), rgba(31,19,38,0.88));
    }
    /* Light theme: hide outer square on icons/items */
    :root[data-theme="light"] .icon-sprite { box-shadow: none; }
    :root[data-theme="light"] .item { border-color: transparent; }
    :root[data-theme="light"] .item:hover { border-color: transparent; }
  </style>
  <script src="data.js"></script>
</head>
<body>
  <header>
    <div class="wrap header-row">
      <h1>DQVCアイテムリスト生成</h1>
      <div class="grow"></div>
      <div class="toolbar">
        <label class="muted" for="lang">言語</label>
        <select id="lang" class="select">
          <option value="ja">日本語</option>
          <option value="en">English</option>
          <option value="es">Español</option>
          <option value="fr">Français</option>
          <option value="de">Deutsch</option>
          <option value="it">Italiano</option>
          <option value="alt">Alt</option>
        </select>
        <label class="muted" for="theme">テーマ</label>
        <select id="theme" class="select">
          <option value="dark">ダーク</option>
          <option value="light">ライト</option>
          <option value="blue">ブルー</option>
          <option value="gold">ゴールド</option>
          <option value="pink">ピンク</option>
        </select>
        <div class="search">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="7"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          <input id="q" type="search" placeholder="検索 / Search" autocomplete="off" />
        </div>
        <label class="muted" style="display:flex; align-items:center; gap:6px;">
          <input id="filterSel" type="checkbox" />
          <span id="filterSelLabel">選択済みも検索で絞り込む</span>
        </label>
        <input id="loader" type="file" accept=".bin" style="display:none" />
        <button id="loadBtn" class="btn" title=".bin を読み込む">読み込み</button>
        <button id="downloadBtn" class="btn primary" disabled>ダウンロード</button>
      </div>
    </div>
  </header>

  <main>
    <section class="panel" id="itemsPanel">
      <h2>アイテム</h2>
      <div class="body" id="itemsBody">
        <div class="muted">読み込み中…</div>
      </div>
    </section>

    <section class="panel" id="selectedPanel">
      <h2>選択済み</h2>
      <div class="body">
        <div class="selected-grid" id="selected"></div>
        <div id="selEmpty" class="muted" style="padding:8px 4px">まだアイテムが選択されていません。</div>

        <div id="bulkBox" class="bulk">
          <div class="title" id="bulkTitle">一括個数指定</div>
          <div class="fields">
            <label class="muted" id="bulkPriceLabel" for="bulkPrice">価格</label>
            <input id="bulkPrice" type="text" inputmode="numeric" pattern="\\d*" class="num" />
            <span class="suffix">G</span>

            <label class="muted" id="bulkMinLabel" for="bulkMin">最小</label>
            <input id="bulkMin" type="text" inputmode="numeric" pattern="\\d*" class="num" />
            <span class="suffix">個</span>

            <label class="muted" id="bulkMaxLabel" for="bulkMax">最大</label>
            <input id="bulkMax" type="text" inputmode="numeric" pattern="\\d*" class="num" />
            <span class="suffix">個</span>

            <button id="bulkApply" class="btn">一括適用</button>
          </div>
        </div>

        <div id="bulkDeleteBox" class="bulk">
          <div class="fields" style="gap:8px; flex-wrap:wrap;">
            <button id="delMatched" class="btn">検索でマッチしたものを削除</button>
            <button id="delUnmatched" class="btn">検索でマッチしなかったものを削除</button>
            <button id="delAll" class="btn">すべて削除</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <div class="dropzone" id="drop">
    <div class="inner">
      <div style="font-weight:700; font-size:18px; margin-bottom:6px">ここに .bin ファイルをドロップ</div>
      <div class="muted">Drop a .bin file here to load</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
  // ===================== Utilities =====================
  const textEncoder = new TextEncoder(); // UTF-8 bytes
  const ICON_BY_CODE = new Map(); // DQVC code (hex int) -> icon index
  const KEY = 'XENLONPROJECTKEY';
  const MOD = 0xC2A030D4n;
  const POW32MOD = (1n << 32n) % MOD;
  const MARKER = Uint8Array.from([0xDE,0xED,0xBE,0xEF]);

  const el = id => document.getElementById(id);

  function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn(...args), ms); } }

  // CSV parser (minimal, handles quoted fields)
  function parseCSV(text){
    const rows = [];
    let i = 0, field = '', row = [], inQuotes = false; 
    const pushField = () => { row.push(field); field = ''; };
    const pushRow = () => { if(row.length>1 || (row.length===1 && row[0]!=='')) rows.push(row); row = []; };
    while(i < text.length){
      const c = text[i++];
      if(inQuotes){
        if(c === '"'){
          if(text[i] === '"'){ field += '"'; i++; } else { inQuotes = false; }
        } else { field += c; }
      } else {
        if(c === '"'){ inQuotes = true; }
        else if(c === ','){ pushField(); }
        else if(c === '\n'){ pushField(); pushRow(); }
        else if(c === '\r'){ /* ignore */ }
        else { field += c; }
      }
    }
    if(field.length>0 || row.length>0){ pushField(); pushRow(); }
    return rows;
  }

  // ===================== Binary Writer/Reader =====================
  class BinWriter {
    constructor(){ this.a = []; }
    putByte(v){ this.a.push(v & 0xFF); }
    putLShort(v){ this.a.push(v & 0xFF, (v>>>8) & 0xFF); }
    putLInt(v){ this.a.push(v & 0xFF, (v>>>8)&0xFF, (v>>>16)&0xFF, (v>>>24)&0xFF); }
    putBytes(bytes){ for(const b of bytes) this.a.push(b); }
    putAscii(str){ for(const b of new TextEncoder().encode(str)) this.a.push(b); }
    toUint8(){ return Uint8Array.from(this.a); }
  }
  class BinReader {
    constructor(bytes){ this.b = bytes; this.o = 0; }
    get eof(){ return this.o >= this.b.length; }
    getByte(){ return this.b[this.o++]; }
    getLShort(){ const v = this.b[this.o] | (this.b[this.o+1]<<8); this.o+=2; return v>>>0; }
    getLInt(){ const v = (this.b[this.o] | (this.b[this.o+1]<<8) | (this.b[this.o+2]<<16) | (this.b[this.o+3]<<24))>>>0; this.o+=4; return v; }
    skip(n){ this.o += n; }
    slice(n){ const out = this.b.slice(this.o, this.o+n); this.o += n; return out; }
    remaining(){ return this.b.length - this.o; }
  }

  // ===================== RC4 =====================
  function ksaMasterKey(keyStr){
    const key = new TextEncoder().encode(keyStr); // bytes (UTF-8)
    const S = new Uint8Array(256);
    for(let i=0;i<256;i++) S[i]=i;
    let j=0; 
    for(let i=0;i<256;i++){
      j = (j + S[i] + key[i % key.length]) & 0xFF;
      const t = S[i]; S[i] = S[j]; S[j] = t;
    }
    return S;
  }
  function prgaKeystreamFromMaster(Sin, length){
    const S = new Uint8Array(Sin); // copy
    let i=0, j=0; const out = new Uint8Array(length);
    for(let k=0;k<length;k++){
      i = (i + 1) & 0xFF;
      j = (j + S[i]) & 0xFF;
      const t=S[i]; S[i]=S[j]; S[j]=t;
      const K = S[(S[i] + S[j]) & 0xFF];
      out[k] = K;
    }
    return out;
  }
  function rc4(dataBytes, keyStr){
    const S = ksaMasterKey(keyStr);
    const ks = prgaKeystreamFromMaster(S, dataBytes.length);
    const out = new Uint8Array(dataBytes.length);
    for(let i=0;i<dataBytes.length;i++) out[i] = dataBytes[i] ^ ks[i];
    return out;
  }

  // ===================== Checksum =====================
  function lay_d_23_CheckChecksum(bytes){
    let buf = 0n; let overflow = 0n;
    for(let i=0;i<bytes.length;i++){
      const byte = BigInt(bytes[i]);
      overflow = ((overflow << 8n) | (buf >> 24n)) & 0xFFFFFFFFn;
      buf = ((buf << 8n) + byte) & 0xFFFFFFFFn;
      if(overflow !== 0n){
        const combined = (overflow << 32n) | buf;
        buf = combined % MOD;
        overflow = 0n;
      }
    }
    return Number(buf);
  }
  function calc_fix_bytes_for_zero_hash(buf32){
    const t = (BigInt(buf32) * POW32MOD) % MOD;
    const x = (MOD - t) % MOD;
    return Uint8Array.from([
      Number((x >> 24n) & 0xFFn),
      Number((x >> 16n) & 0xFFn),
      Number((x >> 8n) & 0xFFn),
      Number(x & 0xFFn)
    ]);
  }

  // ===================== Packet build/parse =====================
  function makeItemPackets(ids, metaMap){
    const w = new BinWriter();
    let count = 0;

    // ボディヘッダー(必須)
    w.putLShort(0x65); // command
    w.putByte(1);      // one arg
    w.putByte(0);      // mode 0
    w.putLInt(0);      // 0
    count++;

    w.putLShort(0x64); // command
    w.putByte(1);      // one arg
    w.putByte(0);      // mode 0
    w.putLInt(0);      // 0
    count++;

    // 期限(固定: 2099/12/31)
    w.putLShort(0x67); // command
    w.putByte(3);      // 3 args
    w.putByte(0x15);   // mode 0x15
    w.putLInt(2099 >>> 0);
    w.putLInt(12 >>> 0);
    w.putLInt(31 >>> 0);
    count++;

    for(const id of ids){
      const meta = metaMap && metaMap.get(id) || { price: 10, min: 1, max: 100 };
      const price = (meta.price>>>0); const min = (meta.min>>>0); const max = (meta.max>>>0);
      w.putLShort(0x68); // command
      w.putByte(4);      // 4 args
      w.putByte(0x55);   // mode 0x55
      w.putLInt(id >>> 0);      // id
      w.putLInt(price);         // 販売価格
      w.putLInt(min);           // 最小個数
      w.putLInt(max);           // 最大個数
      count++;
    }
    return { body: w.toUint8(), count };
  }

  function buildFile(ids){
    const { body, count } = makeItemPackets(ids, state.meta);

    const hdr = new BinWriter();
    hdr.putLInt(count);
    hdr.putLInt(body.length);
    hdr.putLInt(0x1b);
    hdr.putLInt(0x2);
    hdr.putBytes(body);
    // Tail string: "2011/03/23 17:09:05\x001102323\x00"
    hdr.putAscii('2011/03/23'); hdr.putByte(0x20); hdr.putAscii('17:09:05'); hdr.putByte(0x00);
    hdr.putAscii('1102323'); hdr.putByte(0x00);

    // pad to 16 with 0xFF
    let bytes = hdr.toUint8();
    const pad = (16 - (bytes.length % 16)) % 16;
    if(pad>0){ const ff = new Uint8Array(pad); ff.fill(0xFF); bytes = concat(bytes, ff); }
    bytes = concat(bytes, MARKER);

    // encrypt
    const enc = rc4(bytes, KEY);
    // replace last 4 bytes with checksum fix
    let final = enc.slice(0, enc.length - 4);
    const fix = calc_fix_bytes_for_zero_hash(lay_d_23_CheckChecksum(final));
    final = concat(final, fix);

    // sanity: verify zero
    const chk = lay_d_23_CheckChecksum(final);
    if(chk !== 0){ console.warn('Checksum not zero:', chk); }

    return final; // Uint8Array
  }
  function parseFile(bin){
    // verify checksum
    const sum = lay_d_23_CheckChecksum(bin);
    if(sum !== 0){ throw new Error('チェックサムが不正です。'); }
    // decrypt; note last 4 bytes were replaced with checksum; we'll decrypt anyway and patch tail marker
    const dec = rc4(bin, KEY);
    let plain = dec.slice(0, dec.length - 4);
    plain = concat(plain, MARKER); // restore original marker

    const r = new BinReader(plain);
    const packetCount = r.getLInt();
    const bodyLen = r.getLInt();
    const v1 = r.getLInt();
    const v2 = r.getLInt();
    if(v1 !== 0x1b || v2 !== 0x2){ /* tolerate but warn */ }
    const body = r.slice(bodyLen);

    const entries = [];
    const pr = new BinReader(body);
    while(!pr.eof && pr.remaining() >= 4){
      const cmd = pr.getLShort();
      if(pr.remaining() < 2) break;
      const c = pr.getByte();
      const mode = pr.getByte();
      if(pr.remaining() < c*4) break;
      const args=[]; for(let i=0;i<c;i++) args.push(pr.getLInt());
      if(cmd === 0x68 && args.length >= 4){
        const [id, price, min, max] = args;
        entries.push({ id: id>>>0, price: price>>>0, min: min>>>0, max: max>>>0 });
      }
    }
    return entries;
  }

  function concat(a, b){ const out = new Uint8Array(a.length + b.length); out.set(a,0); out.set(b,a.length); return out; }

  // ===================== Data and UI =====================
  const state = {
    items: [], // {id, type, en, ja, icon}
    groups: new Map(), // type -> items[]
    lang: 'ja',
    q: '',
    selected: new Set(), // of id
    meta: new Map(), // id -> {price, min, max}
    filterSelected: false, // whether to filter Selected list by master search
  };

  function iconIndexFromId(id){
    // Reverse lookup using prepared map (filled during CSV load)
    return ICON_BY_CODE.has(id) ? ICON_BY_CODE.get(id) : 0;
  }
  function iconStyleFromIndex(idx){
    if(idx == null || idx < 0) idx = 0; // fallback
    const x = 1 + 25 * (idx % 11);
    const y = 1 + 25 * Math.floor(idx / 11);
    return `background-position: -${x}px -${y}px;`;
  }

  async function loadCSV(){
    const res = await fetch('dq9items.csv');
    const text = await res.text();
    const rows = parseCSV(text);
    // header indexes
    const header = rows[0];
    const idxCode = header.indexOf('Code');
    const idxType = header.indexOf('Type');
    const itemDX = header.indexOf('Item #');
    const idxEn = header.indexOf('English');
    const idxJa = header.indexOf('Japanese');
    const idxAlt = header.indexOf('Alt');
    const idxEs = header.indexOf('Spanish');
    const idxFr = header.indexOf('French');
    const idxDe = header.indexOf('German');
    const idxIt = header.indexOf('Italian');
    const itemsArr = [];
    for(let i=1;i<rows.length;i++){
      const r = rows[i];
      if(!r || r.length === 0) continue;
      const code = r[idxCode];
      const type = r[idxType];
      const item = r[itemDX];
      const en = r[idxEn];
      const ja = r[idxJa];
      const alt = idxAlt>=0 ? r[idxAlt] : '';
      const es = idxEs>=0 ? r[idxEs] : '';
      const fr = idxFr>=0 ? r[idxFr] : '';
      const de = idxDe>=0 ? r[idxDe] : '';
      const it = idxIt>=0 ? r[idxIt] : '';
      if(!code || !type) continue;
      const id = parseInt(code, 16);
      const itemid = parseInt(item, 10);
      // icon index: prefer data.js mapping by id, fallback to CSV Item #
      const dataItem = (typeof items !== 'undefined') ? items[id] : undefined;
      const icon = (dataItem && typeof dataItem.icon === 'number') ? dataItem.icon : (Number.isFinite(itemid) ? itemid : 0);
      ICON_BY_CODE.set(id, icon);
      itemsArr.push({ id, type, en, ja, alt, es, fr, de, it, icon });
    }
    state.items = itemsArr;
    // group by type
    const map = new Map();
    for(const it of itemsArr){
      if(!map.has(it.type)) map.set(it.type, []);
      map.get(it.type).push(it);
    }
    // sort each group by id
    for(const g of map.values()) g.sort((a,b)=>a.id-b.id);
    state.groups = map;
  }

  function getItemName(it, lang){
    if(!it) return '';
    switch(lang){
      case 'ja': return it.ja || it.en || it.alt || it.es || it.fr || it.de || it.it || '';
      case 'en': return it.en || it.ja || it.alt || it.es || it.fr || it.de || it.it || '';
      case 'es': return it.es || it.en || it.ja || it.fr || it.de || it.it || it.alt || '';
      case 'fr': return it.fr || it.en || it.ja || it.es || it.de || it.it || it.alt || '';
      case 'de': return it.de || it.en || it.ja || it.es || it.fr || it.it || it.alt || '';
      case 'it': return it.it || it.en || it.ja || it.es || it.fr || it.de || it.alt || '';
      case 'alt': return it.alt || it.ja || it.en || it.es || it.fr || it.de || it.it || '';
      default: return it.en || it.ja || it.alt || it.es || it.fr || it.de || it.it || '';
    }
  }

  // translation helper for dynamic UI
  function t(key){
    const lang = state.lang;
    let dict = translations[lang];
    if(lang === 'alt'){
      const auto = (navigator.language || 'en').slice(0,2).toLowerCase();
      dict = translations[auto] || translations.en;
    }
    if(!dict) dict = translations.ja;
    return (dict && key in dict) ? dict[key] : (translations.ja[key] || key);
  }

  function render(){
    renderItems();
    renderSelected();
    el('downloadBtn').disabled = state.selected.size === 0;
  }

  function renderItems(){
    const body = el('itemsBody');
    body.innerHTML = '';
    const q = state.q.trim().toLowerCase();
    const lang = state.lang;

    for(const [type, arr] of state.groups){
      // filter by search
      const vis = [];
      for(const it of arr){
        const name = getItemName(it, lang) || '';
        if(q && !name.toLowerCase().includes(q)) continue;
        vis.push(it);
      }
      if(vis.length === 0) continue;

      const det = document.createElement('details');
      det.className = 'type';
      det.open = true;
      const sum = document.createElement('summary');
      sum.textContent = `${type} ・ ${vis.length}`;
      det.appendChild(sum);

      const grid = document.createElement('div');
      grid.className = 'type-items';

      for(const it of vis){
        const row = document.createElement('label');
        row.className = 'item';
        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.className = 'check';
        chk.checked = state.selected.has(it.id);
        chk.addEventListener('change', ()=>{
          if(chk.checked){
            state.selected.add(it.id);
            if(!state.meta.has(it.id)) state.meta.set(it.id, { price: 10, min: 1, max: 1 });
          } else {
            state.selected.delete(it.id);
          }
          renderSelected();
          el('downloadBtn').disabled = state.selected.size === 0;
        });

        const icon = document.createElement('i');
        icon.className = 'icon-sprite';
        icon.style = iconStyleFromIndex(it.icon);

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = getItemName(it, lang) || `(0x${it.id.toString(16).toUpperCase()})`;

        const code = document.createElement('div');
        code.className = 'muted';
        code.style.fontSize = '11px';
        code.textContent = `0x${it.id.toString(16).toUpperCase()}`;

        row.appendChild(chk);
        row.appendChild(icon);
        row.appendChild(name);
        row.appendChild(code);
        grid.appendChild(row);
      }

      det.appendChild(grid);
      body.appendChild(det);
    }

    if(!body.childElementCount){
      const div = document.createElement('div');
      div.className = 'muted';
      div.textContent = '該当するアイテムがありません。';
      body.appendChild(div);
    }
  }

  function renderSelected(){
    const holder = el('selected');
    holder.innerHTML = '';
    const lang = state.lang;
    const selEmpty = el('selEmpty');
    const ids = Array.from(state.selected).sort((a,b)=>a-b);
    // Show empty message only when nothing is selected (not based on filter)
    selEmpty.style.display = ids.length? 'none':'block';

    const onlyDigits = (s)=> s.replace(/\D+/g, '');

    const q = state.q.trim().toLowerCase();
    const doFilter = !!(state.filterSelected && q.length);

    for(const id of ids){
      const it = state.items.find(x=>x.id===id);
      const nameStr = it ? (getItemName(it, lang)||'') : `Unknown 0x${id.toString(16).toUpperCase()}`;
      if(doFilter && !nameStr.toLowerCase().includes(q)) continue; // hide by filter

      const meta = state.meta.get(id) || { price: 10, min: 1, max: 100 };
      state.meta.set(id, meta);

      const row = document.createElement('div');
      row.className = 'sel';

      const icon = document.createElement('i');
      icon.className = 'icon-sprite';
      icon.style = iconStyleFromIndex(it? it.icon : iconIndexFromId(id));

      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = nameStr;

      const code = document.createElement('div');
      code.className='muted'; code.style.fontSize='11px';
      code.textContent = `0x${id.toString(16).toUpperCase()}`;

      const fields = document.createElement('div');
      fields.className = 'fields';

      const price = document.createElement('input');
      price.type = 'text'; price.inputMode = 'numeric'; price.pattern = '\\d*';
      price.className = 'num'; price.value = String(meta.price ?? 0);
      price.title = t('priceLabel') || '価格';
      price.addEventListener('input', ()=>{
        const v = onlyDigits(price.value);
        price.value = v;
        meta.price = (v === '' ? 0 : parseInt(v,10));
        state.meta.set(id, meta);
      });
      const g = document.createElement('span'); g.className='suffix'; g.textContent = 'G';

      const minLabel = document.createElement('span');
      minLabel.className = 'muted';
      minLabel.textContent = t('minLabel');

      const min = document.createElement('input');
      min.type = 'text'; min.inputMode = 'numeric'; min.pattern = '\\d*';
      min.className = 'num'; min.value = String(meta.min ?? 1);
      min.title = t('minLabel');
      min.addEventListener('input', ()=>{
        const v = onlyDigits(min.value);
        min.value = v;
        let vi = (v === '' ? 0 : parseInt(v,10));
        if(vi > (meta.max ?? 0)){
          meta.max = vi;
          max.value = String(meta.max);
        }
        meta.min = vi;
        state.meta.set(id, meta);
      });
      const pcs1 = document.createElement('span'); pcs1.className='suffix'; pcs1.textContent = '個';

      const maxLabel = document.createElement('span');
      maxLabel.className = 'muted';
      maxLabel.textContent = t('maxLabel');

      const max = document.createElement('input');
      max.type = 'text'; max.inputMode = 'numeric'; max.pattern = '\\d*';
      max.className = 'num'; max.value = String(meta.max ?? 100);
      max.title = t('maxLabel');
      max.addEventListener('input', ()=>{
        const v = onlyDigits(max.value);
        max.value = v;
        let vi = (v === '' ? 0 : parseInt(v,10));
        if(vi < (meta.min ?? 0)){
          meta.min = vi;
          min.value = String(meta.min);
        }
        meta.max = vi;
        state.meta.set(id, meta);
      });
      const pcs2 = document.createElement('span'); pcs2.className='suffix'; pcs2.textContent = '個';

      fields.appendChild(price); fields.appendChild(g);
      fields.appendChild(minLabel); fields.appendChild(min); fields.appendChild(pcs1);
      fields.appendChild(maxLabel); fields.appendChild(max); fields.appendChild(pcs2);

      const rm = document.createElement('button');
      rm.className='btn remove'; rm.textContent='×'; rm.title='削除';
      rm.onclick=()=>{ state.selected.delete(id); render(); };

      row.appendChild(icon);
      row.appendChild(name);
      row.appendChild(code);
      row.appendChild(fields);
      row.appendChild(rm);
      holder.appendChild(row);
    }
  }

  // ===================== File IO =====================
  async function onDownload(){
    const ids = Array.from(state.selected).sort((a,b)=>a-b);
    const bin = buildFile(ids);

    const size = bin.length;
    const listTxt = `output.bin\t\tauction\t\t\t${size}\r\r`;

    const zip = new JSZip();
    zip.file('output.bin', bin);
    zip.file('_list.txt', new TextEncoder().encode(listTxt));

    const blob = await zip.generateAsync({type:'blob'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'YDQJ.zip'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  async function loadBinFromFile(file){
    const buf = new Uint8Array(await file.arrayBuffer());
    let entries;
    try{
      entries = parseFile(buf);
    }catch(e){
      alert('読み込み失敗: ' + (e && e.message ? e.message : e));
      return;
    }
    const ids = entries.map(e=>e.id);
    state.selected = new Set(ids);
    state.meta = new Map(entries.map(e=>[e.id, { price: e.price, min: e.min, max: e.max }]));
    render();
  }

  // Drag & drop overlay
  function setupDnD(){
    const drop = el('drop');
    let dragDepth = 0;
    let lastShowAt = 0;
    let hideTimer = null;

    const show = () => {
      lastShowAt = Date.now();
      drop.classList.add('visible');
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
    };
    const scheduleHide = () => {
      const elapsed = Date.now() - lastShowAt;
      const wait = Math.max(500 - elapsed, 0); // keep visible at least 500ms
      if (hideTimer) { clearTimeout(hideTimer); }
      hideTimer = setTimeout(() => { drop.classList.remove('visible'); hideTimer = null; }, wait);
    };

    window.addEventListener('dragenter', (e)=>{ e.preventDefault(); dragDepth++; show(); });
    window.addEventListener('dragover', (e)=>{ e.preventDefault(); show(); });
    window.addEventListener('dragleave', (e)=>{ e.preventDefault(); dragDepth = Math.max(0, dragDepth-1); if(dragDepth===0) scheduleHide(); });
    window.addEventListener('drop', (e)=>{ e.preventDefault(); dragDepth = 0; scheduleHide(); const f = e.dataTransfer.files && e.dataTransfer.files[0]; if(f && f.name.endsWith('.bin')) loadBinFromFile(f); });
  }

  // ===================== Wire up =====================
  function applyTheme(theme){
    document.documentElement.setAttribute('data-theme', theme);
  }


  (async function init(){
    setupDnD();
    el('loadBtn').onclick = ()=> el('loader').click();
    el('loader').onchange = ()=>{ const f = el('loader').files[0]; if(f) loadBinFromFile(f); el('loader').value = ''; };
    el('downloadBtn').onclick = onDownload;

    // restore language and theme from localStorage
    const savedLang = localStorage.getItem('lang');
    if(savedLang){ state.lang = savedLang; }
    el('lang').value = state.lang;

    const savedTheme = localStorage.getItem('theme') || 'dark';
    el('theme').value = savedTheme;
    applyTheme(savedTheme);

    // restore filter-selected flag
    const savedFilter = localStorage.getItem('filterSel');
    state.filterSelected = savedFilter === '1';
    const filterChk = document.getElementById('filterSel');
    if(filterChk){ filterChk.checked = state.filterSelected; }

    // layout handled by CSS media queries

    el('lang').onchange = ()=>{ state.lang = el('lang').value; localStorage.setItem('lang', state.lang); render(); };
    el('theme').onchange = ()=>{ const t = el('theme').value; localStorage.setItem('theme', t); applyTheme(t); };

    if(filterChk){ filterChk.onchange = ()=>{ state.filterSelected = filterChk.checked; localStorage.setItem('filterSel', state.filterSelected ? '1':'0'); renderSelected(); }; }

    // bulk apply handler
    const bulkApplyBtn = document.getElementById('bulkApply');
    if(bulkApplyBtn){
      bulkApplyBtn.onclick = ()=>{
        const ids = Array.from(state.selected);
        if(ids.length===0) return;
        const getNum = (id)=>{
          const v = document.getElementById(id);
          if(!v) return null;
          const s = (v.value||'').replace(/\D+/g,'');
          return s === '' ? null : parseInt(s,10);
        };
        const pVal = getNum('bulkPrice');
        const minValRaw = getNum('bulkMin');
        const maxValRaw = getNum('bulkMax');
        let minVal = minValRaw, maxVal = maxValRaw;
        if(minVal != null && maxVal != null && minVal > maxVal){ const t = minVal; minVal = maxVal; maxVal = t; }
        for(const id of ids){
          const meta = state.meta.get(id) || { price:10, min:1, max:100 };
          if(pVal != null) meta.price = pVal;
          if(minVal != null){
            meta.min = minVal;
            if(maxVal == null && meta.max < minVal){ meta.max = minVal; }
          }
          if(maxVal != null){
            meta.max = maxVal;
            if(minVal == null && meta.min > maxVal){ meta.min = maxVal; }
          }
          if(meta.min > meta.max) meta.max = meta.min;
          state.meta.set(id, meta);
        }
        renderSelected();
      };
    }

    // bulk delete handlers
    function namesForIds(ids){
      const lang = state.lang;
      return ids.map(id=>{
        const it = state.items.find(x=>x.id===id);
        const name = it ? (getItemName(it, lang)||'') : `0x${id.toString(16).toUpperCase()}`;
        return `• ${name} (0x${id.toString(16).toUpperCase()})`;
      });
    }
    function confirmAndDelete(ids){
      if(!ids || ids.length===0) return;
      const msg = t('confirmDelete') + '\n\n' + namesForIds(ids).join('\n');
      if(confirm(msg)){
        for(const id of ids){
          state.selected.delete(id);
          state.meta.delete(id);
        }
        render();
      }
    }
    const btnMatched = document.getElementById('delMatched');
    const btnUnmatched = document.getElementById('delUnmatched');
    const btnAll = document.getElementById('delAll');
    const computeMatches = ()=>{
      const q = (state.q||'').trim().toLowerCase();
      if(!q) return [];
      const ids = Array.from(state.selected);
      const lang = state.lang;
      const matches = [];
      for(const id of ids){
        const it = state.items.find(x=>x.id===id);
        const name = it ? (getItemName(it, lang)||'') : '';
        if(name.toLowerCase().includes(q)) matches.push(id);
      }
      return matches;
    };
    if(btnMatched){ btnMatched.onclick = ()=>{ const ids = computeMatches(); confirmAndDelete(ids); }; }
    if(btnUnmatched){ btnUnmatched.onclick = ()=>{
      const idsSel = Array.from(state.selected);
      const matched = new Set(computeMatches());
      const notMatched = idsSel.filter(id=>!matched.has(id));
      confirmAndDelete(notMatched);
    }; }
    if(btnAll){ btnAll.onclick = ()=>{
      const ids = Array.from(state.selected);
      confirmAndDelete(ids);
    }; }

    el('q').addEventListener('input', debounce(()=>{ state.q = el('q').value; renderItems(); renderSelected(); }, 120));

    await loadCSV();
    render();
  })();
  </script>

<script>
  // lang.js
  // 多言語辞書（テーマの各オプションも含む）
  const translations = {
    ja: {
      title: "DQVCアイテムリスト生成",
      items: "アイテム",
      selected: "選択済み",
      noItem: "まだアイテムが選択されていません。",
      dropTitle: "ここに .bin ファイルをドロップ",
      dropHint: "Drop a .bin file here to load",
      loadBtn: "読み込み",
      downloadBtn: "ダウンロード",
      themeLabel: "テーマ",
      langLabel: "言語",
      searchPlaceholder: "検索 / Search",
      themeDark: "ダーク",
      themeLight: "ライト",
      themeBlue: "ブルー",
      themeGold: "ゴールド",
      themePink: "ピンク",
      priceLabel: "価格",
      minLabel: "最小",
      maxLabel: "最大",
      bulkTitle: "一括個数指定",
      bulkApply: "一括適用",
      filterSelected: "検索で選択済みも絞り込む",
      deleteMatched: "検索でマッチしたものを削除",
      deleteUnmatched: "検索でマッチしなかったものを削除",
      deleteAll: "すべて削除",
      confirmDelete: "下記のアイテムを削除します。よろしいですか",
    },
    en: {
      title: "DQVC Item List Generator",
      items: "Items",
      selected: "Selected",
      noItem: "No items selected yet.",
      dropTitle: "Drop .bin file here",
      dropHint: "Drop a .bin file here to load",
      loadBtn: "Load",
      downloadBtn: "Download",
      themeLabel: "Theme",
      langLabel: "Language",
      searchPlaceholder: "Search",
      themeDark: "Dark",
      themeLight: "Light",
      themeBlue: "Blue",
      themeGold: "Gold",
      themePink: "Pink",
      priceLabel: "Price",
      minLabel: "Min",
      maxLabel: "Max",
      bulkTitle: "Bulk set",
      bulkApply: "Apply to all",
      filterSelected: "Filter selected by search",
      deleteMatched: "Delete items matching the search",
      deleteUnmatched: "Delete items not matching the search",
      deleteAll: "Delete all",
      confirmDelete: "The following items will be removed. Continue?",
    },
    es: {
      title: "Generador de lista de artículos DQVC",
      items: "Artículos",
      selected: "Seleccionados",
      noItem: "Aún no se han seleccionado artículos.",
      dropTitle: "Suelta el archivo .bin aquí",
      dropHint: "Suelta un archivo .bin aquí para cargarlo",
      loadBtn: "Cargar",
      downloadBtn: "Descargar",
      themeLabel: "Tema",
      langLabel: "Idioma",
      searchPlaceholder: "Buscar",
      themeDark: "Oscuro",
      themeLight: "Claro",
      themeBlue: "Azul",
      themeGold: "Oro",
      themePink: "Rosa",
      priceLabel: "Precio",
      minLabel: "Mín",
      maxLabel: "Máx",
      bulkTitle: "Asignación en lote",
      bulkApply: "Aplicar a todos",
      filterSelected: "Filtrar seleccionados por búsqueda",
      deleteMatched: "Eliminar los que coinciden con la búsqueda",
      deleteUnmatched: "Eliminar los que no coinciden con la búsqueda",
      deleteAll: "Eliminar todo",
      confirmDelete: "Se eliminarán los siguientes elementos. ¿Desea continuar?",
    },
    fr: {
      title: "Générateur de liste d'objets DQVC",
      items: "Objets",
      selected: "Sélectionnés",
      noItem: "Aucun objet sélectionné pour le moment.",
      dropTitle: "Déposez le fichier .bin ici",
      dropHint: "Déposez un fichier .bin ici pour le charger",
      loadBtn: "Charger",
      downloadBtn: "Télécharger",
      themeLabel: "Thème",
      langLabel: "Langue",
      searchPlaceholder: "Recherche",
      themeDark: "Sombre",
      themeLight: "Clair",
      themeBlue: "Bleu",
      themeGold: "Or",
      themePink: "Rose",
      priceLabel: "Prix",
      minLabel: "Min",
      maxLabel: "Max",
      bulkTitle: "Affectation en lot",
      bulkApply: "Appliquer à tous",
      filterSelected: "Filtrer les sélectionnés par la recherche",
      deleteMatched: "Supprimer les éléments correspondant à la recherche",
      deleteUnmatched: "Supprimer les éléments ne correspondant pas à la recherche",
      deleteAll: "Tout supprimer",
      confirmDelete: "Les éléments suivants seront supprimés. Continuer ?",
    },
    de: {
      title: "DQVC-Artikel-Listengenerator",
      items: "Artikel",
      selected: "Ausgewählt",
      noItem: "Noch keine Artikel ausgewählt.",
      dropTitle: "Ziehe die .bin-Datei hierher",
      dropHint: "Ziehe eine .bin-Datei hierher, um sie zu laden",
      loadBtn: "Laden",
      downloadBtn: "Herunterladen",
      themeLabel: "Thema",
      langLabel: "Sprache",
      searchPlaceholder: "Suchen",
      themeDark: "Dunkel",
      themeLight: "Hell",
      themeBlue: "Blau",
      themeGold: "Gold",
      themePink: "Rosa",
      priceLabel: "Preis",
      minLabel: "Min",
      maxLabel: "Max",
      bulkTitle: "Sammelzuweisung",
      bulkApply: "Auf alle anwenden",
      filterSelected: "Ausgewählte mit Suche filtern",
      deleteMatched: "Elemente löschen, die der Suche entsprechen",
      deleteUnmatched: "Elemente löschen, die der Suche nicht entsprechen",
      deleteAll: "Alle löschen",
      confirmDelete: "Die folgenden Elemente werden gelöscht. Fortfahren?",
    },
    it: {
      title: "Generatore elenco oggetti DQVC",
      items: "Oggetti",
      selected: "Selezionati",
      noItem: "Nessun oggetto selezionato.",
      dropTitle: "Trascina qui il file .bin",
      dropHint: "Trascina un file .bin qui per caricarlo",
      loadBtn: "Carica",
      downloadBtn: "Scarica",
      themeLabel: "Tema",
      langLabel: "Lingua",
      searchPlaceholder: "Cerca",
      themeDark: "Scuro",
      themeLight: "Chiaro",
      themeBlue: "Blu",
      themeGold: "Oro",
      themePink: "Rosa",
      priceLabel: "Prezzo",
      minLabel: "Min",
      maxLabel: "Max",
      bulkTitle: "Impostazione massiva",
      bulkApply: "Applica a tutti",
      filterSelected: "Filtra selezionati con ricerca",
      deleteMatched: "Elimina gli elementi corrispondenti alla ricerca",
      deleteUnmatched: "Elimina gli elementi non corrispondenti alla ricerca",
      deleteAll: "Elimina tutti",
      confirmDelete: "I seguenti elementi verranno rimossi. Continuare?",
    }
  };

  // 指定言語を適用する関数
  function applyLang(lang) {
    // Alt（自動判別）の場合、ブラウザ言語を利用
    let t;
    if (lang === "alt") {
      const autoLangCode = (navigator.language || navigator.userLanguage || "en").slice(0,2).toLowerCase();
      t = translations[autoLangCode] || translations.en;
    } else {
      t = translations[lang] || translations.ja;
    }

    // ヘルパー：要素が存在する場合のみ書き換え
    const setText = (selector, text) => {
      const el = document.querySelector(selector);
      if (el) el.innerText = text;
    };

    // 単純テキスト置換
    setText("h1", t.title);
    setText("#itemsPanel h2", t.items);
    setText("#selectedPanel h2", t.selected);
    setText("#selEmpty", t.noItem);
    setText("#drop .inner div:first-child", t.dropTitle);
    setText("#drop .inner .muted, #drop .muted", t.dropHint); // 内部の muted 要素を更新
    setText("label[for='lang']", t.langLabel);
    setText("label[for='theme']", t.themeLabel);
    setText("#loadBtn", t.loadBtn);
    setText("#downloadBtn", t.downloadBtn);

    // 新規UI（フィルタ・一括指定）の文言
    setText("#filterSelLabel", t.filterSelected);
    setText("#bulkTitle", t.bulkTitle);
    setText("#bulkPriceLabel", t.priceLabel);
    setText("#bulkMinLabel", t.minLabel);
    setText("#bulkMaxLabel", t.maxLabel);
    setText("#bulkApply", t.bulkApply);
    // 一括削除ボタンの文言
    setText("#delMatched", t.deleteMatched);
    setText("#delUnmatched", t.deleteUnmatched);
    setText("#delAll", t.deleteAll);

    // プレースホルダ更新
    const q = document.getElementById("q");
    if (q) q.placeholder = t.searchPlaceholder;

    // テーマ select の option を更新（value 属性を基準に）
    const optDark = document.querySelector("#theme option[value='dark']");
    const optLight = document.querySelector("#theme option[value='light']");
    const optBlue = document.querySelector("#theme option[value='blue']");
    const optGold = document.querySelector("#theme option[value='gold']");
    const optPink = document.querySelector("#theme option[value='pink']");
    if (optDark) optDark.innerText = t.themeDark;
    if (optLight) optLight.innerText = t.themeLight;
    if (optBlue) optBlue.innerText = t.themeBlue;
    if (optGold) optGold.innerText = t.themeGold;
    if (optPink) optPink.innerText = t.themePink;
  }

  // 初期化：DOMContentLoaded で適用、言語セレクト変更時に再適用
  document.addEventListener("DOMContentLoaded", () => {
    const select = document.getElementById("lang");
    if (!select) {
      // 言語セレクトが無ければデフォルト日本語で適用
      applyLang("ja");
      return;
    }

    // 初期適用（select の現在値を使用）
    applyLang(select.value);

    // ユーザーが言語を切り替えたとき
    select.addEventListener("change", (e) => {
      applyLang(e.target.value);
    });
  });

</script>
</body>
</html>
